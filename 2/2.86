(define (make-table same-key?)
  (define (assoc key records)
    (cond ((null? records) false)
	  ((same-key? key (caar records)) (car records))
	  (else (assoc key (cdr records)))))
  (define (make-node key val records)
    (list key val records))
  (define (key-node node) (car node))
  (define (val-node node) (cadr node))
  (define (records-node node) (caddr node))
  (define (set-key-node! key node)
    (set-car! node key))
  (define (set-val-node! val node)
    (set-car! (cdr node) val))
  (define (set-records-node! records node)
    (set-car! (cddr node) records))
  (let ((local-table (make-node '*table* false '())))
    (define (lookup-internal keys current-table)
      (if (null? keys)
	  (val-node current-table)
	  (let ((subtable (assoc (car keys) (records-node current-table))))
	    (if subtable
		(lookup-internal (cdr keys) subtable)
		false))))
    (define (lookup keys) (lookup-internal keys local-table))
    (define (insert-internal! keys value current-table)
      (if (null? keys)
	  (set-val-node! value current-table)
	  (let ((subtable (assoc (car keys) (records-node current-table))))
	    (if (not subtable)
		(begin (set! subtable
			     (make-node (car keys)
					false
					'()))
		       (set-records-node! (cons subtable
					       (records-node current-table))
					 current-table)))
	    (insert-internal! (cdr keys) value subtable)))
      'ok)
    (define (insert! keys value)
      (insert-internal! keys value local-table))
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
	    ((eq? m 'insert-proc) insert!)
	    (else (error "Unknown operation - TABLE" m))))
    dispatch))

(define (same-key? k dk)
  (if (and (pair? k) (pair? dk))
      (and (same-key? (car k) (car dk)) (same-key? (cdr k) (cdr dk)))
      (eq? k dk)))

;; operation table
(define operation-table (make-table same-key?))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc))

;; coercion table
(define coercion-table (make-table same-key?))
(define get-coercion (coercion-table 'lookup-proc))
(define put-coercion (coercion-table 'insert-proc))

;;;;;;;;;;;;;;; type tags ;;;;;;;;;;;;;
(define (attach-tag type-tag contents)
  (cond ((eq? type-tag 'scheme-number)
	 contents)
	(else
	 (cons type-tag contents))))

(define (type-tag datum)
  (cond ((pair? datum)
	 (car datum))
	((number? datum)
	 'scheme-number)
	(else
	 (error "Bad tagged datum -- TYPE-TAG" datum))))

(define (contents datum)
  (cond ((pair? datum)
	 (cdr datum))
	((number? datum)
	 datum)
	(else
	 (error "Bad tagged data -- CONTENTS" datum))))

;;;;;;;;;;;;;;;;; apply-generic ;;;;;;;;;;;;;;;;;;;;;;;;;
(define tower '(scheme-number rational complex))
;Value: tower

(define (higher-than? t1 t2)
  (< (length (memq t1 tower))
     (length (memq t2 tower))))
;Value: higher-than?

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get (list op type-tags))))
      (if proc
	  (apply proc (map contents args))
	  (if (and (= (length args) 2)
		   (not (eq? (car type-tags) (cadr type-tags))))
	      (let ((type1 (car type-tags))
		    (type2 (cadr type-tags))
		    (a1 (car args))
		    (a2 (cadr args)))
		(if (higher-than? type1 type2)
		    (apply-generic op a1 (raise a2))
		    (apply-generic op (raise a1) a2)))
	      (error
	       "No method for these types -- APPLY-GENERIC"
	       (list op type-tags)))))))
;Value: apply-generic

;;;;;;;;;;;;;;;;;; generic operation ;;;;;;;;;;;;;;;;;;

(define (add x y) (drop (apply-generic 'add x y)))

(define (sub x y) (drop (apply-generic 'sub x y)))

(define (mul x y) (drop (apply-generic 'mul x y)))

(define (div x y) (drop (apply-generic 'div x y)))

(define (equ? x y) (apply-generic 'equ? x y))

;;;;;;;;;;;;;;; scheme-number package ;;;;;;;;;;;;;;;;

(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put '(add (scheme-number scheme-number))
       (lambda (x y) (tag (+ x y))))
  (put '(sub (scheme-number scheme-number))
       (lambda (x y) (tag (- x y))))
  (put '(mul (scheme-number scheme-number))
       (lambda (x y) (tag (* x y))))
  (put '(div (scheme-number scheme-number))
       (lambda (x y) (tag (/ x y))))
  (put '(make scheme-number)
       (lambda (x) (tag x)))
  (put '(equ? (scheme-number scheme-number)) =)
  (put '(=zero? (scheme-number))
       (lambda (x) (= x 0)))
  'done)

;;;;;;;;;;;;;;;;;;;; rational package ;;;;;;;;;;;;;;

(define (install-rational-package)
  ;; internal procedures
   (define (numer x) (car x))
   (define (denom x) (cdr x))
   (define (make-rat n d)
     (let ((g (gcd n d)))
       (cons (/ n g) (/ d g))))
   (define (add-rat x y)
     (make-rat (add (mul (numer x) (denom y))
		    (mul (numer y) (denom x)))
	       (mul (denom x) (denom y))))
   (define (sub-rat x y)
     (make-rat (- (* (numer x) (denom y))
		  (* (numer y) (denom x)))
	       (* (denom x) (denom y))))
   (define (mul-rat x y)
     (make-rat (* (numer x) (numer y))
	       (* (denom x) (denom y))))
   (define (div-rat x y)
     (make-rat (* (numer x) (denom y))
	       (* (denom x) (numer y))))

   (define (equ-rat? x y)
     (and (= (numer x) (numer y))
	  (= (denom x) (denom y))))

   (define (=zero? x)
     (= (numer x) 0))

   ;; interface to rest of the system
   (define (tag x) (attach-tag 'rational x))
   (put '(numer (rational)) numer)
   (put '(denom (rational)) denom)
   (put '(add (rational rational))
	(lambda (x y) (tag (add-rat x y))))
   (put '(sub (rational rational))
	(lambda (x y) (tag (sub-rat x y))))
   (put '(div (rational rational))
	(lambda (x y) (tag (div-rat x y))))
   (put '(mul (rational rational))
	(lambda (x y) (tag (mul-rat x y))))
   (put '(equ? (rational rational)) equ-rat?)
   (put '(=zero? (rational)) =zero?)
   (put '(make rational)
	(lambda (n d) (tag (make-rat n d))))
   'done)
;Value: install-rational-package

(define numer (get '(numer (rational))))
;Value: numer

(define denom (get '(denom (rational))))
;Value: denom

;;;;;;;;;;;;;;;;;;; complex number package ;;;;;;;;;;;;

(define (real-part z) (apply-generic 'real-part z))

(define (imag-part z) (apply-generic 'imag-part z))

(define (magnitude z) (apply-generic 'magnitude z))

(define (angle z) (apply-generic 'angle z))

; rectanglar representation
(define (install-rectangular-package)
  ;; internal procedures
  (define (make-from-mag-ang r a)
    (cons (* r (cos a))
	  (* r (sin a))))
  (define (make-from-real-imag x y)
    (cons x y))
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
	     (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))

  ;; interface to the rest of system
  (define (tag x) (attach-tag 'rectangular x))
  (put '(real-part (rectangular)) real-part)
  (put '(imag-part (rectangular)) imag-part)
  (put '(magnitude (rectangular)) magnitude)
  (put '(angle (rectangular)) angle)
  (put '(make-from-real-imag rectangular)
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put '(make-from-mag-ang rectangular)
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; magnitude angle representation
(define (install-polar-package)
  ;; internal procedures
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
	  (atan y x)))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (magnitude x) (car x))
  (define (angle x) (cdr x))
  
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put '(real-part (polar)) real-part)
  (put '(imag-part (polar)) imag-part)
  (put '(magnitude (polar)) magnitude)
  (put '(angle (polar)) angle)
  (put '(make-from-real-imag polar)
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put '(make-from-mag-ang polar)
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  (define (make-from-real-imag x y)
    ((get '(make-from-real-imag rectangular)) x y))
  (define (make-from-mag-ang r a)
    ((get '(make-from-mag-ang polar)) r a))
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
			 (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
			 (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
		       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
		       (sub (angle z1) (angle z2))))
  (define (equ-complex? z1 z2)
    (and (equ? (real-part z1) (real-part z2))
	 (equ? (imag-part z1) (imag-part z2))))
  ;; interface to rest of system
  (define (tag z) (attach-tag 'complex z))
  (put '(real-part (complex)) real-part)
  (put '(imag-part (complex)) imag-part)
  (put '(magnitude (complex)) magnitude)
  (put '(angle (complex)) angle)
  (put '(add (complex complex))
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put '(sub (complex complex))
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put '(mul (complex complex))
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put '(div (complex complex))
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put '(equ? (complex complex)) equ-complex?)
  (put '(make-from-real-imag complex)
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put '(make-from-mag-ang complex)
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
;Value: install-complex-package

;;;;;;;;;;;;;;;;;; install package ;;;;;;;;;;;;;;;;;;;;;
(install-scheme-number-package)
;Value: done
(install-rational-package)
;Value: done
(define (make-rational n d)
  ((get '(make rational)) n d))
;Value: make-rational
(install-complex-package)
(define make-complex-from-real-imag (get '(make-from-real-imag complex)))
(define make-complex-from-mag-angle (get '(make-from-mag-ang complex)))
(install-rectangular-package)
(install-polar-package)

;;;;;;;;;;;;;;;; coercion ;;;;;;;;;;;;;;;;;;;;;
(define (scheme-number->complex n)
  (make-complex-from-real-imag (contents n) 0))
;Value: scheme-number->complex
(put-coercion '(scheme-number complex) scheme-number->complex)

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)
(put-coercion '(scheme-number scheme-numer) scheme-number->scheme-number)
(put-coercion '(complex complex) complex->complex)
;Value: ok


;;;;;;;;;;;;;;; raise ;;;;;;;;;;;;;;;;;;;;;;;;
(define (raise-scheme-number n)
  (make-rational (contents n) 1))
;Value: raise-scheme-number

(define (raise-rational r)
  (make-complex-from-real-imag (attach-tag 'rational r) 0))
;Value: raise-rational

(put '(raise (scheme-number)) raise-scheme-number)
(put '(raise (rational)) raise-rational)
;Value: ok

(define (raise a) (apply-generic 'raise a))
;Value: raise

(raise 1)
(raise (make-rational 1 1))

;;;;;;;;;;;;;;;; drop ;;;;;;;;;;;;;;;;;;;;;
(define (project-rational r) (numer r))
;Value: project-rational
(define (project-complex z) (real-part z))
;Value: project-complex

(put '(project (rational)) project-rational)
;Value: ok
(put '(project (complex)) project-complex)
;Value: ok

(define (project a) (apply-generic 'project a))
;Value: project

(define (drop a)
  (if (eq? (type-tag a) 'scheme-number)
      a
      (let ((s (project a)))
	(if (equ? a (raise s))
	    (drop s)
	    a))))

(drop (make-complex-from-real-imag 1 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(equ? 1 1)
(equ? 1 2)
(apply (get '(raise (rational))) (list (raise 2)))

(apply raise-rational (list (raise 2)))
(apply-generic 'raise (raise 2))
;Value 135: (complex rectangular (rational 2 . 1) . 0)

;Value 126: (complex rectangular (rational 2 . 1) . 0)


;Value 109: #[compound-procedure 109 raise-rational]

((get '(raise (rational))) (raise 2))
(raise-rational (raise 2))
(raise (make-rational 2 3))
(make-rational 2 3)
;Value 106: (complex rectangular (2 . 1) . 0)
(raise (make-rational 3 1))

(add (make-complex-from-real-imag (make-rational 3 10) 2)
     (make-complex-from-real-imag (make-rational 7 10) 4))
;Value 148: (complex rectangular 1 . 6)

(add (make-rational 3 10) (make-rational 6 1))
;Value 147: (rational 63 . 10)

;Value 139: (complex rectangular  . 6)

(drop (add (make-rational 2 3) 2))

(make-complex-from-real-imag (make-rational 8 3) 6)

(make-rational 1 2)
;Value 65: (rational 1 . 2)

(drop (make-rational 3 2))

(mul (make-rational 1 2) 2)
;Value: 1

(add (make-complex-from-real-imag 1 2) (make-complex-from-real-imag 2 -2))




















