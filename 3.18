(define (detect-cycle x)
  (let ((pair-set '()))
    (define (do-detect x)
      (cond ((not (pair? x))
	     false)
	    ((memq x pair-set)
	     true)
	    (else
	     (set! pair-set (cons x pair-set))
	     (or (do-detect (car x))
		 (do-detect (cdr x))))))

    (do-detect x)))
;Value: detect-cycle

(detect-cycle '(a b c))


;Value: #f
;Value: #t


;Unbound variable: pair
;To continue, call RESTART with an option number:
; (RESTART 12) => Specify a value to use instead of pair.
; (RESTART 11) => Define pair to a given value.
; (RESTART 10) => Return to read-eval-print level 10.
; (RESTART 9) => Return to read-eval-print level 9.
; (RESTART 8) => Return to read-eval-print level 8.
; (RESTART 7) => Return to read-eval-print level 7.
; (RESTART 6) => Return to read-eval-print level 6.
; (RESTART 5) => Return to read-eval-print level 5.
; (RESTART 4) => Return to read-eval-print level 4.
; (RESTART 3) => Return to read-eval-print level 3.
; (RESTART 2) => Return to read-eval-print level 2.
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n


;Value: #f


(define (count-pairs x)
  (let ((pair-set '()))
    (define (count-pairs-r x)
      (if (and (pair? x)
	       (not (memq x pair-set)))
	  (begin (set! pair-set (cons x pair-set))
		 (+ (count-pairs-r (car x))
		    (count-pairs-r (cdr x))
		    1))
	  0))
    (count-pairs-r x)))
;Value: count-pairs

(define p1 (cons 'a1 (cons 'a2 (cons '3 '()))))
;Value: p1

(count-pairs p1)
;Value: 3

(define p2 (list 't))
;Value: p2
(define p3 (cons p2 (cons 'b p2)))
;Value: p3
p3
;Value 23: ((t) b t)

(count-pairs p3)
;Value: 3

(define p4 (cons p2 p2))
;Value: p4
(define p5 (cons p4 p4))
;Value: p5
(count-pairs p5)
;Value: 3

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
;Value: last-pair

(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
;Value: make-cycle

(count-pairs (make-cycle (list 'a 'b 'c)))
;Value: 3



(((t) b t))
((b t))
((t))
((t))
;Value: 4

(memq p2 (cons p2 '()))
;Value 24: ((t))

(cons p2 '())
;Value 25: ((t))

(cons (list 'a) (cons (list 'b) '()))
;Value 29: ((a) (b))
;Value 28: ((a) b)


;Unbound variable: disply
;To continue, call RESTART with an option number:
; (RESTART 11) => Specify a value to use instead of disply.
; (RESTART 10) => Define disply to a given value.
; (RESTART 9) => Return to read-eval-print level 9.
; (RESTART 8) => Return to read-eval-print level 8.
; (RESTART 7) => Return to read-eval-print level 7.
; (RESTART 6) => Return to read-eval-print level 6.
; (RESTART 5) => Return to read-eval-print level 5.
; (RESTART 4) => Return to read-eval-print level 4.
; (RESTART 3) => Return to read-eval-print level 3.
; (RESTART 2) => Return to read-eval-print level 2.
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n




;Unbound variable: p2
;To continue, call RESTART with an option number:
; (RESTART 10) => Specify a value to use instead of p2.
; (RESTART 9) => Define p2 to a given value.
; (RESTART 8) => Return to read-eval-print level 8.
; (RESTART 7) => Return to read-eval-print level 7.
; (RESTART 6) => Return to read-eval-print level 6.
; (RESTART 5) => Return to read-eval-print level 5.
; (RESTART 4) => Return to read-eval-print level 4.
; (RESTART 3) => Return to read-eval-print level 3.
; (RESTART 2) => Return to read-eval-print level 2.
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n


;The object (), passed as the first argument to cdr, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 8) => Specify an argument to use in its place.
; (RESTART 7) => Return to read-eval-print level 7.
; (RESTART 6) => Return to read-eval-print level 6.
; (RESTART 5) => Return to read-eval-print level 5.
; (RESTART 4) => Return to read-eval-print level 4.
; (RESTART 3) => Return to read-eval-print level 3.
; (RESTART 2) => Return to read-eval-print level 2.
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n


;The object (), passed as the first argument to cdr, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 7) => Specify an argument to use in its place.
; (RESTART 6) => Return to read-eval-print level 6.
; (RESTART 5) => Return to read-eval-print level 5.
; (RESTART 4) => Return to read-eval-print level 4.
; (RESTART 3) => Return to read-eval-print level 3.
; (RESTART 2) => Return to read-eval-print level 2.
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n


;Unbound variable: const
;To continue, call RESTART with an option number:
; (RESTART 7) => Specify a value to use instead of const.
; (RESTART 6) => Define const to a given value.
; (RESTART 5) => Return to read-eval-print level 5.
; (RESTART 4) => Return to read-eval-print level 4.
; (RESTART 3) => Return to read-eval-print level 3.
; (RESTART 2) => Return to read-eval-print level 2.
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n




(define p '(a b))
;Value: p

(cons 'a1 (cons (cons (cons p '()) 'a2 ) '()))
;Value 22: (a1 (((a b)) . a2))

;Value: #f

; (RESTART 1)
;Value 21: ((a b))
;Value 19: (a1 a2 (a b) . b1)


;The procedure #[compiled-procedure 18 ("list" #x3) #x14 #x10e4254bc] has been called with 1 argument; it requires exactly 2 arguments.
;To continue, call RESTART with an option number:
; (RESTART 3) => Return to read-eval-print level 3.
; (RESTART 2) => Return to read-eval-print level 2.
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n


;Value 17: (a1 (a b) . b1)

;Value 16: ((a b) . b1)

(memq 'a '())
;Value: #f

(memq '(a b c d) '(a b))
;Value: #f

(memq '(a b c d) 'a)
;The object a, passed as an argument to memq, is not a list.
;To continue, call RESTART with an option number:
; (RESTART 2) => Return to read-eval-print level 2.
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n

(memq 'a '(a b c))
;Value 13: (a b c)

(memq 'b '(a b c))
;Value 14: (b c)

(not '(b c))
;Value: #f



(eq? 1 1)
;Value: #t

(= 'a 'a)
;The object a, passed as the first argument to integer-equal?, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 2) => Specify an argument to use in its place.
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n







Copyright (C) 2014 Massachusetts Institute of Technology
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Image saved on Saturday May 17, 2014 at 2:39:25 AM
  Release 9.2 || Microcode 15.3 || Runtime 15.7 || SF 4.41 || LIAR/x86-64 4.118
  Edwin 3.116
;You are in an interaction window of the Edwin editor.
;Type `C-h' for help, or `C-h t' for a tutorial.
;`C-h m' will describe some commands.
;`C-h' means: hold down the Ctrl key and type `h'.
;Package: (user)

